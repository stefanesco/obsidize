{:deps {org.babashka/json {:mvn/version "0.1.6"}}

 :tasks
 {:requires ([babashka.process :refer [shell]]
             [babashka.fs :as fs]
             [clojure.string :as str]
             [babashka.json :as json])

  ;; ---
  ;; UTILITY TASKS
  ;; ---
  clean
  {:doc "Clean up generated files and artifacts."
   :task (do
           (println "üßπ Cleaning up generated files...")
           (doseq [p ["target" "trivy-report.json" "test-output" "out"
                      "test-e2e-vault" "test-vault-integration"]]
             (when (fs/exists? p)
               (try
                 (if (fs/directory? p)
                   (fs/delete-tree p)
                   (fs/delete p))
                 (catch Exception e
                   (println "‚ö†Ô∏è  Could not delete" p ":" (.getMessage e))))))
           (println "‚úÖ Cleanup complete."))}

  ;; ---
  ;; SETUP & INSTALLATION
  ;; ---
  init
  {:doc "Install all project dependencies (Clojure)."
   :task (do (println "üîß Initializing project and installing dependencies...")
             (shell "clojure -P")
             (println "‚úÖ Dependencies installed."))}

  ;; ---
  ;; LINTING TASKS
  ;; ---
  lint
  {:doc "Lint Clojure source code with clj-kondo (warnings non-blocking)."
   :task (try
           (shell "clj-kondo --lint src test")
           (println "‚úÖ Clojure linting passed with no errors.")
           (catch Exception e
             (let [exit-code (:exit (ex-data e))]
               (if (= exit-code 2)
                 (println "‚ö†Ô∏è  Clojure linting completed with warnings (non-blocking).")
                 (throw e)))))}

  ;; ---
  ;; TESTING TASKS
  ;; ---
  test
  {:doc "Run Clojure tests with Kaocha and generate a coverage report."
   :task (shell "clojure -M:test")}

  ;; ---
  ;; AUDITING & SECURITY TASKS
  ;; ---
  audit
  {:doc "Check for outdated Clojure dependencies with antq (Linux only)."
   :task (when (= "Linux" (System/getProperty "os.name"))
           (println "üî¨ Checking for outdated dependencies on Linux...")
           (shell "clojure -M:antq"))}

  check-trivy
  {:doc "Check if Trivy is installed and available on the PATH."
   :task (when-not (fs/which "trivy")
           (println "‚ùå Trivy is not installed or not in your PATH.")
           (println "   Please install it to run security scans (e.g., 'brew install aquasecurity/trivy/trivy').")
           (System/exit 1))}

  generate-pom
  {:doc "Generate pom.xml from deps.edn for vulnerability scanning."
   :task (do
           (fs/create-dirs "target")
           (shell "clojure -Spom > target/pom.xml"))}

  trivy-scan
  {:doc "Run Trivy to scan for vulns and licenses, generating a report."
   :depends [generate-pom check-trivy]
   :task (shell {:extra-env {"TRIVY_SKIP_CLIENT_DOCKER_CREDENTIALS" "true"
                             "DOCKER_CONFIG" ""}}
                "trivy fs . --scanners vuln,license --format json -o target/trivy-report.json --severity HIGH,CRITICAL")}

  trivy-check
  {:doc "Parse Trivy report for vulnerabilities and license issues, then fail if needed."
   :depends [trivy-scan]
   :task
   (let [report (-> "target/trivy-report.json" slurp (json/read-str {:key-fn keyword}))
         results (get-in report [:Results] [])
         disallowed-licenses #{}
         vuln-issues (->> results (mapcat :Vulnerabilities) (filter some?) (filter (fn [x] (contains? #{"HIGH" "CRITICAL"} (:Severity x)))))
         license-issues (->> results (mapcat :Packages) (filter some?) (filter (fn [pkg] (some disallowed-licenses (:Licenses pkg)))))]
     (if (and (empty? vuln-issues) (empty? license-issues))
       (println "‚úÖ Trivy scan passed: No critical vulnerabilities or disallowed licenses found.")
       (do
         (println "---")
         (when (not-empty vuln-issues)
           (println "‚ùå Found HIGH/CRITICAL vulnerabilities:")
           (doseq [{:keys [PkgName VulnerabilityID Severity]} vuln-issues]
             (println (format "  - %s: [%s] %s" PkgName Severity VulnerabilityID))))
         (when (not-empty license-issues)
           (println "\n‚ùå Found packages with disallowed licenses:")
           (doseq [{:keys [Name Licenses]} license-issues]
             (println (format "  - %s (License: %s)" Name (str/join ", " Licenses)))))
         (println "\n Failing build due to security/license issues.")
         (System/exit 1))))}

  verify
  {:doc "Run all security and dependency audits."
   :depends [audit trivy-check]}

  ;; ---
  ;; BUILD & CI TASKS
  ;; ---
  check
  {:doc "Run all checks: lint, test, and audit."
   :depends [lint test verify]}

  ci
  {:doc "Run the full CI pipeline: install dependencies and run all checks."
   :depends [init lint test verify]}

  ;; ---
  ;; PACKAGING & RELEASE TASKS (aligned with build.clj)
  ;; ---
  uber-runtime
  {:doc "Build a standalone uberjar of the application (runtime)."
   :override-builtin true
   :task (shell "clojure -T:build uber-runtime")}

  native-prereqs
  {:doc "Check for GraalVM native-image prerequisites."
   :task (when-not (fs/which "native-image")
           (println "‚ùå GraalVM 'native-image' command not found.")
           (println "   Please install GraalVM and configure your PATH.")
           (println "   See: https://www.graalvm.org/latest/reference-manual/native-image/#install-native-image")
           (System/exit 1))}

  native-image
  {:doc "Build a native executable using GraalVM (uses native uber JAR and flags)."
   :depends [native-prereqs]
   :task (shell "clojure -T:build native-image")}

  jlink-image
  {:doc "Create jlink runtime image and archive (bundles native exe on macOS if present)."
   :task (shell "clojure -T:build jlink-image")}

  package
  {:doc "Build runtime uber, native image, and jlink archive."
   :task (shell "clojure -T:build build-all")}

  ;; ---
  ;; NEW: DIST ‚Äî list paths of latest build artifacts
  ;; ---
  ;; ---
  ;; DIST ‚Äî list paths of latest build artifacts (robust native detection)
  ;; ---
  dist
  {:doc "List artifact paths in the latest target/release/<version> directory."
   :task (do
           (when-not (fs/exists? "target/release")
             (println "‚ùå No release directory found. Run `bb package` first.")
             (System/exit 1))
           (let [versions (->> (fs/list-dir "target/release")
                               (filter fs/directory?)
                               (map fs/file-name)
                               (filter (fn [x] (re-matches (re-pattern ".+") x)))
                               sort)
                 latest (last versions)]
             (when-not latest
               (println "‚ùå No versioned release directory found in target/release.")
               (System/exit 1))
             (let [base     (str "target/release/" latest)
                   jar      (str base "/obsidize-standalone.jar")
                   ;; search for common native names
                   candidates [(str base "/obsidize-native")
                               (str base "/obsidize")
                               (str base "/obsidize-native.exe")
                               (str base "/obsidize.exe")]
                   natives  (filter fs/exists? candidates)
                   archives (->> (fs/list-dir base)
                                 (map str)
                                 (filter (fn [x] (re-find (re-pattern "(?:\\.tar\\.gz|\\.zip)$") x)))
                                 sort)]
               (println "üì¶ Latest release artifacts for version:" latest)
               (when (fs/exists? jar)
                 (println "  ‚Ä¢ Uberjar:     " jar))
               (if (seq natives)
                 (do
                   (println "  ‚Ä¢ Native:")
                   (doseq [n natives]
                     (println "     - " n)))
                 (println "  ‚Ä¢ Native:      [not found]"))
               (if (seq archives)
                 (do
                   (println "  ‚Ä¢ Archives:")
                   (doseq [a archives] (println "     - " a)))
                 (println "  ‚Ä¢ Archives:    [none]")))))}

  ;; ---
  ;; NEW: RELEASE ‚Äî run git-release.sh <version> then package
  ;; ---
  release
  {:doc "Run git-release.sh <version> (arg or $VERSION), then build artifacts (bb package)."
   :task (let [args *command-line-args*
               version (or (first args) (System/getenv "VERSION"))]
           (when (str/blank? (or version ""))
             (println "‚ùå Version not provided. Usage: `bb release <version>` or set env VERSION.")
             (System/exit 1))
           (when-not (fs/exists? "git-release.sh")
             (println "‚ùå Missing git-release.sh in project root.")
             (System/exit 1))
           (println (format "üè∑Ô∏è  Tagging and creating release %s..." version))
           (let [res (shell (format "bash ./git-release.sh %s" version))]
             (when-not (zero? (:exit res))
               (println "‚ùå git-release.sh failed.")
               (System/exit (:exit res))))
           (println "üì¶ Building artifacts (bb package)...")
           (let [res2 (shell "bb package")]
             (when-not (zero? (:exit res2))
               (println "‚ùå Packaging failed.")
               (System/exit (:exit res2))))
           (println "‚úÖ Release flow completed. Run `bb dist` to see artifacts."))}}}