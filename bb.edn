{:deps {org.babashka/json {:mvn/version "0.1.6"}}

 :tasks
 {:requires ([babashka.process :refer [shell]]
             [babashka.fs :as fs]
             [clojure.string :as str]
             [babashka.json :as json])

  ;; Security Policy Configuration
  :security-policy
  {:disallowed-licenses #{}
   :max-cvss-score 7.0
   :vulnerability-whitelist #{}
   :min-severity "HIGH"}

  ;; --- 
  ;; UTILITY TASKS
  ;; --- 
  clean
  {:doc "Clean up generated files and artifacts."
   :task (do
           (println "üßπ Cleaning up generated files...")
           (doseq [p ["target" "trivy-report.json" "test-output" "out"
                      "test-e2e-vault" "test-vault-integration"]]
             (when (fs/exists? p)
               (try
                 (if (fs/directory? p)
                   (fs/delete-tree p)
                   (fs/delete p))
                 (catch Exception e
                   (println "‚ö†Ô∏è  Could not delete" p ":" (.getMessage e))))))
           (println "‚úÖ Cleanup complete."))}

  ;; --- 
  ;; SETUP & INSTALLATION
  ;; --- 
  init
  {:doc "Install all project dependencies (Clojure)."
   :task (let [clj-cmd (if (fs/which "clojure") "clojure"
                           (if (fs/which "clojure.exe") "clojure.exe"
                               (if (fs/which "clj") "clj"
                                   (throw (ex-info "Clojure CLI not found in PATH. Please install Clojure CLI tools." {})))))]
           (println "üîß Initializing project and installing dependencies...")
           (shell (str clj-cmd " -P"))
           (println "‚úÖ Dependencies installed."))}

  ;; --- 
  ;; LINTING TASKS
  ;; --- 
  lint
  {:doc "Lint Clojure source code with clj-kondo (warnings non-blocking)."
   :task (try
           (shell "clj-kondo --lint src test")
           (println "‚úÖ Clojure linting passed with no errors.")
           (catch Exception e
             (let [exit-code (:exit (ex-data e))]
               (if (= exit-code 2)
                 (println "‚ö†Ô∏è  Clojure linting completed with warnings (non-blocking).")
                 (throw e)))))}

  ;; --- 
  ;; TESTING TASKS
  ;; --- 
  test-unit
  {:doc "Run unit tests with Kaocha (excludes e2e tests)."
   :task (let [clj-cmd (if (fs/which "clojure") "clojure"
                           (if (fs/which "clojure.exe") "clojure.exe"
                               (if (fs/which "clj") "clj"
                                   (throw (ex-info "Clojure CLI not found in PATH. Please install Clojure CLI tools." {})))))]
           (try
             (shell (str clj-cmd " -M:test :unit"))
             (println "‚úÖ All unit tests passed!")
             (catch Exception e
               (let [exit-code (:exit (ex-data e))]
                 (cond
                   (= exit-code 1) (do
                                     (println "‚ö†Ô∏è  Some tests failed. Check output above for details.")
                                     (println "   Use 'clojure -M:test :unit' directly for verbose output."))
                   (= exit-code 2) (do
                                     (println "‚ö†Ô∏è  Test errors detected. Check output above for details.")
                                     (println "   Use 'clojure -M:test :unit' directly for verbose output."))
                   :else (throw e))))))}

  test
  {:doc "Run all unit tests."
   :depends [test-unit]}

  test-e2e
  {:doc "Run end-to-end package validation tests with compiled artifacts."
   :task (let [clj-cmd (if (fs/which "clojure") "clojure"
                           (if (fs/which "clojure.exe") "clojure.exe"
                               (if (fs/which "clj") "clj"
                                   (throw (ex-info "Clojure CLI not found in PATH. Please install Clojure CLI tools." {})))))]
           (println "üß™ Running end-to-end package validation tests...")
           (println "   This validates JAR, native image, and CLI functionality with real data.")
           (try
             (shell (str clj-cmd " -M:test :e2e"))
             (println "‚úÖ E2E package validation tests passed!")
             (catch Exception e
               (let [exit-code (:exit (ex-data e))]
                 (cond
                   (= exit-code 1) (do
                                     (println "‚ö†Ô∏è  Some E2E tests failed. This indicates issues with compiled packages.")
                                     (println "   Build packages first: bb package")
                                     (println "   Then run: clojure -M:test :e2e"))
                   (= exit-code 2) (do
                                     (println "‚ö†Ô∏è  E2E test errors detected.")
                                     (println "   Ensure packages are built: bb package"))
                   :else (throw e))))))}

  ;; --- 
  ;; AUDITING & SECURITY TASKS
  ;; --- 
  audit
  {:doc "Check for outdated Clojure dependencies with antq (Linux only)."
   :task (let [clj-cmd (if (fs/which "clojure") "clojure"
                           (if (fs/which "clojure.exe") "clojure.exe"
                               (if (fs/which "clj") "clj"
                                   (throw (ex-info "Clojure CLI not found in PATH. Please install Clojure CLI tools." {})))))]
           (when (= "Linux" (System/getProperty "os.name"))
             (println "üî¨ Checking for outdated dependencies on Linux...")
             (try
               (shell (str clj-cmd " -M:antq"))
               (println "‚úÖ Dependency audit completed successfully.")
               (catch Exception e
                 (let [exit-code (:exit (ex-data e))]
                   (cond
                     (= exit-code 1) (println "‚ö†Ô∏è  Dependency audit found issues (non-blocking).")
                     (= exit-code 2) (println "‚ö†Ô∏è  Dependency audit errors detected (non-breaking).")
                     :else (do
                             (println "‚ö†Ô∏è  Dependency audit failed unexpectedly (non-breaking).")
                             (println "   Error:" (.getMessage e)))))))))}

  check-trivy
  {:doc "Check if Trivy is installed and available on the PATH."
   :task (when-not (fs/which "trivy")
           (println "‚ùå Trivy is not installed or not in your PATH.")
           (println "   Please install it to run security scans (e.g., 'brew install aquasecurity/trivy/trivy').")
           (System/exit 1))}

  generate-pom
  {:doc "Generate pom.xml from deps.edn for vulnerability scanning."
   :task (let [clj-cmd (if (fs/which "clojure") "clojure"
                           (if (fs/which "clojure.exe") "clojure.exe"
                               (if (fs/which "clj") "clj"
                                   (throw (ex-info "Clojure CLI not found in PATH. Please install Clojure CLI tools." {})))))]
           (fs/create-dirs "target")
           (shell (str clj-cmd " -Spom > target/pom.xml")))}

  trivy-scan
  {:doc "Run Trivy to scan for vulns and licenses, generating a report."
   :depends [generate-pom check-trivy]
   :task (shell {:extra-env {"TRIVY_SKIP_CLIENT_DOCKER_CREDENTIALS" "true"
                             "DOCKER_CONFIG" ""}}
                "trivy fs . --scanners vuln,license --format json -o target/trivy-report.json --severity HIGH,CRITICAL")}

  trivy-check
  {:doc "Parse Trivy report for vulnerabilities and license issues, then fail if needed."
   :depends [trivy-scan]
   :task
   (let [report (-> "target/trivy-report.json" slurp (json/read-str {:key-fn keyword}))
         results (get-in report [:Results] [])
         ;; Access security policy directly from the tasks configuration
         security-policy {:disallowed-licenses #{}
                          :max-cvss-score 7.0
                          :vulnerability-whitelist #{}
                          :min-severity "HIGH"}
         disallowed-licenses (:disallowed-licenses security-policy)
         vuln-issues (->> results (mapcat :Vulnerabilities) (filter some?) (filter (fn [x] (contains? #{"HIGH" "CRITICAL"} (:Severity x)))))
         license-issues (->> results (mapcat :Packages) (filter some?) (filter (fn [pkg] (some disallowed-licenses (set (:Licenses pkg))))))]
     (println (format "üîç Security scan using policy: %d disallowed licenses" (count disallowed-licenses)))
     (if (and (empty? vuln-issues) (empty? license-issues))
       (println "‚úÖ Trivy scan passed: No security policy violations found.")
       (do
         (println "‚ùå Security policy violations detected:")
         (println "---")
         (when (not-empty vuln-issues)
           (println (format "Found %d HIGH/CRITICAL vulnerabilities:" (count vuln-issues)))
           (doseq [{:keys [PkgName VulnerabilityID Severity CVSS]} vuln-issues]
             (let [score (get-in CVSS [:V3Score] "N/A")]
               (println (format "  - %s: [%s] %s (CVSS: %s)" PkgName Severity VulnerabilityID score)))))
         (when (not-empty license-issues)
           (println (format "\nFound %d packages with disallowed licenses:" (count license-issues)))
           (doseq [{:keys [Name Licenses]} license-issues]
             (let [bad-licenses (filter disallowed-licenses (set Licenses))]
               (println (format "  - %s (Disallowed: %s)" Name (str/join ", " bad-licenses))))))
         (println "\n‚ùå Failing build due to security policy violations.")
         (System/exit 1))))}

  verify
  {:doc "Run all security and dependency audits."
   :depends [audit trivy-check]}

  ;; --- 
  ;; BUILD & CI TASKS
  ;; --- 
  check
  {:doc "Run all checks: lint, test, and audit."
   :depends [lint test-unit verify]}

  ci
  {:doc "Run the full CI pipeline: install dependencies and run all checks."
   :depends [init lint test-unit verify]}

  ;; --- 
  ;; PACKAGING & RELEASE TASKS (aligned with build.clj)
  ;; --- 
  uber-runtime
  {:doc "Build a standalone uberjar of the application (runtime)."
   :override-builtin true
   :task (let [clj-cmd (if (fs/which "clojure") "clojure"
                           (if (fs/which "clojure.exe") "clojure.exe"
                               (if (fs/which "clj") "clj"
                                   (throw (ex-info "Clojure CLI not found in PATH. Please install Clojure CLI tools." {})))))]
           (shell (str clj-cmd " -T:build uber-runtime")))}

  native-prereqs
  {:doc "Check for GraalVM native-image prerequisites."
   :task (when-not (fs/which "native-image")
           (println "‚ùå GraalVM 'native-image' command not found.")
           (println "   Please install GraalVM and configure your PATH.")
           (println "   See: https://www.graalvm.org/latest/reference-manual/native-image/#install-native-image")
           (System/exit 1))}

  native-image
  {:doc "Build a native executable using GraalVM (uses native uber JAR and flags)."
   :depends [native-prereqs]
   :task (let [clj-cmd (if (fs/which "clojure") "clojure"
                           (if (fs/which "clojure.exe") "clojure.exe"
                               (if (fs/which "clj") "clj"
                                   (throw (ex-info "Clojure CLI not found in PATH. Please install Clojure CLI tools." {})))))]
           (shell (str clj-cmd " -T:build native-image")))}

  jlink-image
  {:doc "Create jlink runtime image and archive (bundles native exe on macOS ARM64 if present)."
   :task (let [clj-cmd (if (fs/which "clojure") "clojure"
                           (if (fs/which "clojure.exe") "clojure.exe"
                               (if (fs/which "clj") "clj"
                                   (throw (ex-info "Clojure CLI not found in PATH. Please install Clojure CLI tools." {})))))]
           (shell (str clj-cmd " -T:build jlink-image")))}

  package
  {:doc "Build runtime uber, native image, and jlink archive."
   :task (let [clj-cmd (if (fs/which "clojure") "clojure"
                           (if (fs/which "clojure.exe") "clojure.exe"
                               (if (fs/which "clj") "clj"
                                   (throw (ex-info "Clojure CLI not found in PATH. Please install Clojure CLI tools." {})))))]
           (shell (str clj-cmd " -T:build build-all")))}

  verify-package
  {:doc "Build all packages and run end-to-end tests against them."
   :depends [package test-e2e]}

  validate-release
  {:doc "Build packages and run comprehensive e2e validation across all supported artifacts."
   :depends [package test-e2e]
   :task (do
           (println "üß™ Running comprehensive package validation...")
           (println "   ‚úÖ All artifacts built and validated with end-to-end tests")
           (println "   üì¶ JAR, native image, and jlink packages tested")
           (println "   üîß CLI functionality validated with real Claude export data")
           (println "‚úÖ Release validation complete - all packages ready for distribution"))}
  ;; --- 
  ;; NEW: DIST ‚Äî list paths of latest build artifacts
  ;; --- 
  ;; --- 
  ;; DIST ‚Äî list paths of latest build artifacts (robust native detection)
  ;; --- 
  dist
  {:doc "List artifact paths in the latest target/release/<version> directory."
   :task (do
           (when-not (fs/exists? "target/release")
             (println "‚ùå No release directory found. Run `bb package` first.")
             (System/exit 1))
           (let [versions (->> (fs/list-dir "target/release")
                               (filter fs/directory?)
                               (map fs/file-name)
                               (filter (fn [x] (re-matches (re-pattern ".+") x)))
                               sort)
                 latest (last versions)]
             (when-not latest
               (println "‚ùå No versioned release directory found in target/release.")
               (System/exit 1))
             (let [base (str "target/release/" latest)
                   jar (str base "/obsidize-standalone.jar")
                   ;; search for common native names
                   candidates [(str base "/obsidize-native")
                               (str base "/obsidize")
                               (str base "/obsidize-native.exe")
                               (str base "/obsidize.exe")]
                   natives (filter fs/exists? candidates)
                   archives (->> (fs/list-dir base)
                                 (map str)
                                 (filter (fn [x] (re-find (re-pattern "(?:\\.tar\\.gz|\\.zip)$") x)))
                                 sort)]
               (println "üì¶ Latest release artifacts for version:" latest)
               (when (fs/exists? jar)
                 (println "  ‚Ä¢ Uberjar:     " jar))
               (if (seq natives)
                 (do
                   (println "  ‚Ä¢ Native:")
                   (doseq [n natives] (println "     - " n)))
                 (println "  ‚Ä¢ Native:      [not found]"))
               (if (seq archives)
                 (do
                   (println "  ‚Ä¢ Archives:")
                   (doseq [a archives] (println "     - " a)))
                 (println "  ‚Ä¢ Archives:    [none]")))))}

  ;; --- 
  ;; NEW: RELEASE ‚Äî run git-release.sh <version> then package
  ;; --- 
  release
  {:doc "Run git-release.sh <version> (arg or $VERSION), then build and validate artifacts (bb verify-package)."
   :task (let [args *command-line-args*
               version (or (first args) (System/getenv "VERSION"))]

           (when (str/blank? (or version ""))
             (println "‚ùå Version not provided. Usage: `bb release <version>` or set env VERSION.")
             (System/exit 1))

           ;; Security: Validate version format to prevent command injection
           (when-not (re-matches (re-pattern "^v?[0-9]+\\.[0-9]+\\.[0-9]+(-[a-zA-Z0-9.-]+)?$") version)
             (println (format "‚ùå Invalid version format: %s" version))
             (println "   Expected format: 1.2.3, v1.2.3, or v1.2.3-alpha.1")
             (System/exit 1))
           (println (format "‚úÖ Version format validated: %s" version))

           (when-not (fs/exists? "git-release.sh")
             (println "‚ùå Missing git-release.sh in project root.")
             (System/exit 1))
           (println (format "üè∑Ô∏è  Tagging and creating release %s..." version))

           (let [res (shell "bash" "./git-release.sh" version)] ; Use array args to prevent injection
             (when-not (zero? (:exit res))
               (println "‚ùå git-release.sh failed.")
               (System/exit (:exit res))))
           (println "üì¶ Building and validating artifacts with e2e tests...")

           (let [res2 (shell "bb validate-release")]
             (when-not (zero? (:exit res2))
               (println "‚ùå Release validation failed.")
               (System/exit (:exit res2))))
           (println "‚úÖ Release flow completed. Run `bb dist` to see artifacts."))}}}